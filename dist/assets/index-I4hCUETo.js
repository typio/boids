var Q=Object.defineProperty;var J=(P,t,s)=>t in P?Q(P,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):P[t]=s;var T=(P,t,s)=>J(P,typeof t!="symbol"?t+"":t,s);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&e(i)}).observe(document,{childList:!0,subtree:!0});function s(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function e(n){if(n.ep)return;n.ep=!0;const r=s(n);fetch(n.href,r)}})();const I=1e-6,$=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),N=class N extends Float32Array{constructor(...t){switch(t.length){case 16:super(t);break;case 2:super(t[0],t[1],16);break;case 1:const s=t[0];typeof s=="number"?super([s,s,s,s,s,s,s,s,s,s,s,s,s,s,s,s]):super(s,0,16);break;default:super($);break}}get str(){return N.str(this)}copy(t){return this.set(t),this}identity(){return this.set($),this}multiply(t){return N.multiply(this,this,t)}mul(t){return this}transpose(){return N.transpose(this,this)}invert(){return N.invert(this,this)}translate(t){return N.translate(this,this,t)}rotate(t,s){return N.rotate(this,this,t,s)}scale(t){return N.scale(this,this,t)}rotateX(t){return N.rotateX(this,this,t)}rotateY(t){return N.rotateY(this,this,t)}rotateZ(t){return N.rotateZ(this,this,t)}perspectiveNO(t,s,e,n){return N.perspectiveNO(this,t,s,e,n)}perspectiveZO(t,s,e,n){return N.perspectiveZO(this,t,s,e,n)}orthoNO(t,s,e,n,r,i){return N.orthoNO(this,t,s,e,n,r,i)}orthoZO(t,s,e,n,r,i){return N.orthoZO(this,t,s,e,n,r,i)}static create(){return new N}static clone(t){return new N(t)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static fromValues(...t){return new N(...t)}static set(t,...s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static transpose(t,s){if(t===s){const e=s[1],n=s[2],r=s[3],i=s[6],c=s[7],a=s[11];t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=e,t[6]=s[9],t[7]=s[13],t[8]=n,t[9]=i,t[11]=s[14],t[12]=r,t[13]=c,t[14]=a}else t[0]=s[0],t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=s[1],t[5]=s[5],t[6]=s[9],t[7]=s[13],t[8]=s[2],t[9]=s[6],t[10]=s[10],t[11]=s[14],t[12]=s[3],t[13]=s[7],t[14]=s[11],t[15]=s[15];return t}static invert(t,s){const e=s[0],n=s[1],r=s[2],i=s[3],c=s[4],a=s[5],l=s[6],h=s[7],o=s[8],d=s[9],M=s[10],y=s[11],m=s[12],f=s[13],x=s[14],g=s[15],q=e*a-n*c,w=e*l-r*c,v=e*h-i*c,z=n*l-r*a,b=n*h-i*a,S=r*h-i*l,D=o*f-d*m,C=o*x-M*m,E=o*g-y*m,V=d*x-M*f,L=d*g-y*f,F=M*g-y*x;let A=q*F-w*L+v*V+z*E-b*C+S*D;return A?(A=1/A,t[0]=(a*F-l*L+h*V)*A,t[1]=(r*L-n*F-i*V)*A,t[2]=(f*S-x*b+g*z)*A,t[3]=(M*b-d*S-y*z)*A,t[4]=(l*E-c*F-h*C)*A,t[5]=(e*F-r*E+i*C)*A,t[6]=(x*v-m*S-g*w)*A,t[7]=(o*S-M*v+y*w)*A,t[8]=(c*L-a*E+h*D)*A,t[9]=(n*E-e*L-i*D)*A,t[10]=(m*b-f*v+g*q)*A,t[11]=(d*v-o*b-y*q)*A,t[12]=(a*C-c*V-l*D)*A,t[13]=(e*V-n*C+r*D)*A,t[14]=(f*w-m*z-x*q)*A,t[15]=(o*z-d*w+M*q)*A,t):null}static adjoint(t,s){const e=s[0],n=s[1],r=s[2],i=s[3],c=s[4],a=s[5],l=s[6],h=s[7],o=s[8],d=s[9],M=s[10],y=s[11],m=s[12],f=s[13],x=s[14],g=s[15],q=e*a-n*c,w=e*l-r*c,v=e*h-i*c,z=n*l-r*a,b=n*h-i*a,S=r*h-i*l,D=o*f-d*m,C=o*x-M*m,E=o*g-y*m,V=d*x-M*f,L=d*g-y*f,F=M*g-y*x;return t[0]=a*F-l*L+h*V,t[1]=r*L-n*F-i*V,t[2]=f*S-x*b+g*z,t[3]=M*b-d*S-y*z,t[4]=l*E-c*F-h*C,t[5]=e*F-r*E+i*C,t[6]=x*v-m*S-g*w,t[7]=o*S-M*v+y*w,t[8]=c*L-a*E+h*D,t[9]=n*E-e*L-i*D,t[10]=m*b-f*v+g*q,t[11]=d*v-o*b-y*q,t[12]=a*C-c*V-l*D,t[13]=e*V-n*C+r*D,t[14]=f*w-m*z-x*q,t[15]=o*z-d*w+M*q,t}static determinant(t){const s=t[0],e=t[1],n=t[2],r=t[3],i=t[4],c=t[5],a=t[6],l=t[7],h=t[8],o=t[9],d=t[10],M=t[11],y=t[12],m=t[13],f=t[14],x=t[15],g=s*c-e*i,q=s*a-n*i,w=e*a-n*c,v=h*m-o*y,z=h*f-d*y,b=o*f-d*m,S=s*b-e*z+n*v,D=i*b-c*z+a*v,C=h*w-o*q+d*g,E=y*w-m*q+f*g;return l*S-r*D+x*C-M*E}static multiply(t,s,e){const n=s[0],r=s[1],i=s[2],c=s[3],a=s[4],l=s[5],h=s[6],o=s[7],d=s[8],M=s[9],y=s[10],m=s[11],f=s[12],x=s[13],g=s[14],q=s[15];let w=e[0],v=e[1],z=e[2],b=e[3];return t[0]=w*n+v*a+z*d+b*f,t[1]=w*r+v*l+z*M+b*x,t[2]=w*i+v*h+z*y+b*g,t[3]=w*c+v*o+z*m+b*q,w=e[4],v=e[5],z=e[6],b=e[7],t[4]=w*n+v*a+z*d+b*f,t[5]=w*r+v*l+z*M+b*x,t[6]=w*i+v*h+z*y+b*g,t[7]=w*c+v*o+z*m+b*q,w=e[8],v=e[9],z=e[10],b=e[11],t[8]=w*n+v*a+z*d+b*f,t[9]=w*r+v*l+z*M+b*x,t[10]=w*i+v*h+z*y+b*g,t[11]=w*c+v*o+z*m+b*q,w=e[12],v=e[13],z=e[14],b=e[15],t[12]=w*n+v*a+z*d+b*f,t[13]=w*r+v*l+z*M+b*x,t[14]=w*i+v*h+z*y+b*g,t[15]=w*c+v*o+z*m+b*q,t}static mul(t,s,e){return t}static translate(t,s,e){const n=e[0],r=e[1],i=e[2];if(s===t)t[12]=s[0]*n+s[4]*r+s[8]*i+s[12],t[13]=s[1]*n+s[5]*r+s[9]*i+s[13],t[14]=s[2]*n+s[6]*r+s[10]*i+s[14],t[15]=s[3]*n+s[7]*r+s[11]*i+s[15];else{const c=s[0],a=s[1],l=s[2],h=s[3],o=s[4],d=s[5],M=s[6],y=s[7],m=s[8],f=s[9],x=s[10],g=s[11];t[0]=c,t[1]=a,t[2]=l,t[3]=h,t[4]=o,t[5]=d,t[6]=M,t[7]=y,t[8]=m,t[9]=f,t[10]=x,t[11]=g,t[12]=c*n+o*r+m*i+s[12],t[13]=a*n+d*r+f*i+s[13],t[14]=l*n+M*r+x*i+s[14],t[15]=h*n+y*r+g*i+s[15]}return t}static scale(t,s,e){const n=e[0],r=e[1],i=e[2];return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=s[7]*r,t[8]=s[8]*i,t[9]=s[9]*i,t[10]=s[10]*i,t[11]=s[11]*i,t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static rotate(t,s,e,n){let r=n[0],i=n[1],c=n[2],a=Math.sqrt(r*r+i*i+c*c);if(a<I)return null;a=1/a,r*=a,i*=a,c*=a;const l=Math.sin(e),h=Math.cos(e),o=1-h,d=s[0],M=s[1],y=s[2],m=s[3],f=s[4],x=s[5],g=s[6],q=s[7],w=s[8],v=s[9],z=s[10],b=s[11],S=r*r*o+h,D=i*r*o+c*l,C=c*r*o-i*l,E=r*i*o-c*l,V=i*i*o+h,L=c*i*o+r*l,F=r*c*o+i*l,A=i*c*o-r*l,k=c*c*o+h;return t[0]=d*S+f*D+w*C,t[1]=M*S+x*D+v*C,t[2]=y*S+g*D+z*C,t[3]=m*S+q*D+b*C,t[4]=d*E+f*V+w*L,t[5]=M*E+x*V+v*L,t[6]=y*E+g*V+z*L,t[7]=m*E+q*V+b*L,t[8]=d*F+f*A+w*k,t[9]=M*F+x*A+v*k,t[10]=y*F+g*A+z*k,t[11]=m*F+q*A+b*k,s!==t&&(t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t}static rotateX(t,s,e){let n=Math.sin(e),r=Math.cos(e),i=s[4],c=s[5],a=s[6],l=s[7],h=s[8],o=s[9],d=s[10],M=s[11];return s!==t&&(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[4]=i*r+h*n,t[5]=c*r+o*n,t[6]=a*r+d*n,t[7]=l*r+M*n,t[8]=h*r-i*n,t[9]=o*r-c*n,t[10]=d*r-a*n,t[11]=M*r-l*n,t}static rotateY(t,s,e){let n=Math.sin(e),r=Math.cos(e),i=s[0],c=s[1],a=s[2],l=s[3],h=s[8],o=s[9],d=s[10],M=s[11];return s!==t&&(t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=i*r-h*n,t[1]=c*r-o*n,t[2]=a*r-d*n,t[3]=l*r-M*n,t[8]=i*n+h*r,t[9]=c*n+o*r,t[10]=a*n+d*r,t[11]=l*n+M*r,t}static rotateZ(t,s,e){let n=Math.sin(e),r=Math.cos(e),i=s[0],c=s[1],a=s[2],l=s[3],h=s[4],o=s[5],d=s[6],M=s[7];return s!==t&&(t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=i*r+h*n,t[1]=c*r+o*n,t[2]=a*r+d*n,t[3]=l*r+M*n,t[4]=h*r-i*n,t[5]=o*r-c*n,t[6]=d*r-a*n,t[7]=M*r-l*n,t}static fromTranslation(t,s){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=s[0],t[13]=s[1],t[14]=s[2],t[15]=1,t}static fromScaling(t,s){return t[0]=s[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=s[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotation(t,s,e){let n=e[0],r=e[1],i=e[2],c=Math.sqrt(n*n+r*r+i*i);if(c<I)return null;c=1/c,n*=c,r*=c,i*=c;const a=Math.sin(s),l=Math.cos(s),h=1-l;return t[0]=n*n*h+l,t[1]=r*n*h+i*a,t[2]=i*n*h-r*a,t[3]=0,t[4]=n*r*h-i*a,t[5]=r*r*h+l,t[6]=i*r*h+n*a,t[7]=0,t[8]=n*i*h+r*a,t[9]=r*i*h-n*a,t[10]=i*i*h+l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromXRotation(t,s){let e=Math.sin(s),n=Math.cos(s);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=e,t[7]=0,t[8]=0,t[9]=-e,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromYRotation(t,s){let e=Math.sin(s),n=Math.cos(s);return t[0]=n,t[1]=0,t[2]=-e,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=e,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromZRotation(t,s){const e=Math.sin(s),n=Math.cos(s);return t[0]=n,t[1]=e,t[2]=0,t[3]=0,t[4]=-e,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotationTranslation(t,s,e){const n=s[0],r=s[1],i=s[2],c=s[3],a=n+n,l=r+r,h=i+i,o=n*a,d=n*l,M=n*h,y=r*l,m=r*h,f=i*h,x=c*a,g=c*l,q=c*h;return t[0]=1-(y+f),t[1]=d+q,t[2]=M-g,t[3]=0,t[4]=d-q,t[5]=1-(o+f),t[6]=m+x,t[7]=0,t[8]=M+g,t[9]=m-x,t[10]=1-(o+y),t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}static fromQuat2(t,s){const e=-s[0],n=-s[1],r=-s[2],i=s[3],c=s[4],a=s[5],l=s[6],h=s[7];let o=e*e+n*n+r*r+i*i;return o>0?(R[0]=(c*i+h*e+a*r-l*n)*2/o,R[1]=(a*i+h*n+l*e-c*r)*2/o,R[2]=(l*i+h*r+c*n-a*e)*2/o):(R[0]=(c*i+h*e+a*r-l*n)*2,R[1]=(a*i+h*n+l*e-c*r)*2,R[2]=(l*i+h*r+c*n-a*e)*2),N.fromRotationTranslation(t,s,R),t}static normalFromMat4(t,s){const e=s[0],n=s[1],r=s[2],i=s[3],c=s[4],a=s[5],l=s[6],h=s[7],o=s[8],d=s[9],M=s[10],y=s[11],m=s[12],f=s[13],x=s[14],g=s[15],q=e*a-n*c,w=e*l-r*c,v=e*h-i*c,z=n*l-r*a,b=n*h-i*a,S=r*h-i*l,D=o*f-d*m,C=o*x-M*m,E=o*g-y*m,V=d*x-M*f,L=d*g-y*f,F=M*g-y*x;let A=q*F-w*L+v*V+z*E-b*C+S*D;return A?(A=1/A,t[0]=(a*F-l*L+h*V)*A,t[1]=(l*E-c*F-h*C)*A,t[2]=(c*L-a*E+h*D)*A,t[3]=0,t[4]=(r*L-n*F-i*V)*A,t[5]=(e*F-r*E+i*C)*A,t[6]=(n*E-e*L-i*D)*A,t[7]=0,t[8]=(f*S-x*b+g*z)*A,t[9]=(x*v-m*S-g*w)*A,t[10]=(m*b-f*v+g*q)*A,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t):null}static normalFromMat4Fast(t,s){const e=s[0],n=s[1],r=s[2],i=s[4],c=s[5],a=s[6],l=s[8],h=s[9],o=s[10];return t[0]=c*o-o*h,t[1]=a*l-l*o,t[2]=i*h-h*l,t[3]=0,t[4]=h*r-o*n,t[5]=o*e-l*r,t[6]=l*n-h*e,t[7]=0,t[8]=n*a-r*c,t[9]=r*i-e*a,t[10]=e*c-n*i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static getTranslation(t,s){return t[0]=s[12],t[1]=s[13],t[2]=s[14],t}static getScaling(t,s){const e=s[0],n=s[1],r=s[2],i=s[4],c=s[5],a=s[6],l=s[8],h=s[9],o=s[10];return t[0]=Math.sqrt(e*e+n*n+r*r),t[1]=Math.sqrt(i*i+c*c+a*a),t[2]=Math.sqrt(l*l+h*h+o*o),t}static getRotation(t,s){N.getScaling(R,s);const e=1/R[0],n=1/R[1],r=1/R[2],i=s[0]*e,c=s[1]*n,a=s[2]*r,l=s[4]*e,h=s[5]*n,o=s[6]*r,d=s[8]*e,M=s[9]*n,y=s[10]*r,m=i+h+y;let f=0;return m>0?(f=Math.sqrt(m+1)*2,t[3]=.25*f,t[0]=(o-M)/f,t[1]=(d-a)/f,t[2]=(c-l)/f):i>h&&i>y?(f=Math.sqrt(1+i-h-y)*2,t[3]=(o-M)/f,t[0]=.25*f,t[1]=(c+l)/f,t[2]=(d+a)/f):h>y?(f=Math.sqrt(1+h-i-y)*2,t[3]=(d-a)/f,t[0]=(c+l)/f,t[1]=.25*f,t[2]=(o+M)/f):(f=Math.sqrt(1+y-i-h)*2,t[3]=(c-l)/f,t[0]=(d+a)/f,t[1]=(o+M)/f,t[2]=.25*f),t}static decompose(t,s,e,n){s[0]=n[12],s[1]=n[13],s[2]=n[14];const r=n[0],i=n[1],c=n[2],a=n[4],l=n[5],h=n[6],o=n[8],d=n[9],M=n[10];e[0]=Math.sqrt(r*r+i*i+c*c),e[1]=Math.sqrt(a*a+l*l+h*h),e[2]=Math.sqrt(o*o+d*d+M*M);const y=1/e[0],m=1/e[1],f=1/e[2],x=r*y,g=i*m,q=c*f,w=a*y,v=l*m,z=h*f,b=o*y,S=d*m,D=M*f,C=x+v+D;let E=0;return C>0?(E=Math.sqrt(C+1)*2,t[3]=.25*E,t[0]=(z-S)/E,t[1]=(b-q)/E,t[2]=(g-w)/E):x>v&&x>D?(E=Math.sqrt(1+x-v-D)*2,t[3]=(z-S)/E,t[0]=.25*E,t[1]=(g+w)/E,t[2]=(b+q)/E):v>D?(E=Math.sqrt(1+v-x-D)*2,t[3]=(b-q)/E,t[0]=(g+w)/E,t[1]=.25*E,t[2]=(z+S)/E):(E=Math.sqrt(1+D-x-v)*2,t[3]=(g-w)/E,t[0]=(b+q)/E,t[1]=(z+S)/E,t[2]=.25*E),t}static fromRotationTranslationScale(t,s,e,n){const r=s[0],i=s[1],c=s[2],a=s[3],l=r+r,h=i+i,o=c+c,d=r*l,M=r*h,y=r*o,m=i*h,f=i*o,x=c*o,g=a*l,q=a*h,w=a*o,v=n[0],z=n[1],b=n[2];return t[0]=(1-(m+x))*v,t[1]=(M+w)*v,t[2]=(y-q)*v,t[3]=0,t[4]=(M-w)*z,t[5]=(1-(d+x))*z,t[6]=(f+g)*z,t[7]=0,t[8]=(y+q)*b,t[9]=(f-g)*b,t[10]=(1-(d+m))*b,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}static fromRotationTranslationScaleOrigin(t,s,e,n,r){const i=s[0],c=s[1],a=s[2],l=s[3],h=i+i,o=c+c,d=a+a,M=i*h,y=i*o,m=i*d,f=c*o,x=c*d,g=a*d,q=l*h,w=l*o,v=l*d,z=n[0],b=n[1],S=n[2],D=r[0],C=r[1],E=r[2],V=(1-(f+g))*z,L=(y+v)*z,F=(m-w)*z,A=(y-v)*b,k=(1-(M+g))*b,Y=(x+q)*b,j=(m+w)*S,Z=(x-q)*S,H=(1-(M+f))*S;return t[0]=V,t[1]=L,t[2]=F,t[3]=0,t[4]=A,t[5]=k,t[6]=Y,t[7]=0,t[8]=j,t[9]=Z,t[10]=H,t[11]=0,t[12]=e[0]+D-(V*D+A*C+j*E),t[13]=e[1]+C-(L*D+k*C+Z*E),t[14]=e[2]+E-(F*D+Y*C+H*E),t[15]=1,t}static fromQuat(t,s){const e=s[0],n=s[1],r=s[2],i=s[3],c=e+e,a=n+n,l=r+r,h=e*c,o=n*c,d=n*a,M=r*c,y=r*a,m=r*l,f=i*c,x=i*a,g=i*l;return t[0]=1-d-m,t[1]=o+g,t[2]=M-x,t[3]=0,t[4]=o-g,t[5]=1-h-m,t[6]=y+f,t[7]=0,t[8]=M+x,t[9]=y-f,t[10]=1-h-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static frustumNO(t,s,e,n,r,i,c=1/0){const a=1/(e-s),l=1/(r-n);if(t[0]=i*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i*2*l,t[6]=0,t[7]=0,t[8]=(e+s)*a,t[9]=(r+n)*l,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,c!=null&&c!==1/0){const h=1/(i-c);t[10]=(c+i)*h,t[14]=2*c*i*h}else t[10]=-1,t[14]=-2*i;return t}static frustum(t,s,e,n,r,i,c=1/0){return t}static frustumZO(t,s,e,n,r,i,c=1/0){const a=1/(e-s),l=1/(r-n);if(t[0]=i*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i*2*l,t[6]=0,t[7]=0,t[8]=(e+s)*a,t[9]=(r+n)*l,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,c!=null&&c!==1/0){const h=1/(i-c);t[10]=c*h,t[14]=c*i*h}else t[10]=-1,t[14]=-i;return t}static perspectiveNO(t,s,e,n,r=1/0){const i=1/Math.tan(s/2);if(t[0]=i/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const c=1/(n-r);t[10]=(r+n)*c,t[14]=2*r*n*c}else t[10]=-1,t[14]=-2*n;return t}static perspective(t,s,e,n,r=1/0){return t}static perspectiveZO(t,s,e,n,r=1/0){const i=1/Math.tan(s/2);if(t[0]=i/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const c=1/(n-r);t[10]=r*c,t[14]=r*n*c}else t[10]=-1,t[14]=-n;return t}static perspectiveFromFieldOfView(t,s,e,n){const r=Math.tan(s.upDegrees*Math.PI/180),i=Math.tan(s.downDegrees*Math.PI/180),c=Math.tan(s.leftDegrees*Math.PI/180),a=Math.tan(s.rightDegrees*Math.PI/180),l=2/(c+a),h=2/(r+i);return t[0]=l,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=h,t[6]=0,t[7]=0,t[8]=-((c-a)*l*.5),t[9]=(r-i)*h*.5,t[10]=n/(e-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*e/(e-n),t[15]=0,t}static orthoNO(t,s,e,n,r,i,c){const a=1/(s-e),l=1/(n-r),h=1/(i-c);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(s+e)*a,t[13]=(r+n)*l,t[14]=(c+i)*h,t[15]=1,t}static ortho(t,s,e,n,r,i,c){return t}static orthoZO(t,s,e,n,r,i,c){const a=1/(s-e),l=1/(n-r),h=1/(i-c);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=h,t[11]=0,t[12]=(s+e)*a,t[13]=(r+n)*l,t[14]=i*h,t[15]=1,t}static lookAt(t,s,e,n){const r=s[0],i=s[1],c=s[2],a=n[0],l=n[1],h=n[2],o=e[0],d=e[1],M=e[2];if(Math.abs(r-o)<I&&Math.abs(i-d)<I&&Math.abs(c-M)<I)return N.identity(t);let y=r-o,m=i-d,f=c-M,x=1/Math.sqrt(y*y+m*m+f*f);y*=x,m*=x,f*=x;let g=l*f-h*m,q=h*y-a*f,w=a*m-l*y;x=Math.sqrt(g*g+q*q+w*w),x?(x=1/x,g*=x,q*=x,w*=x):(g=0,q=0,w=0);let v=m*w-f*q,z=f*g-y*w,b=y*q-m*g;return x=Math.sqrt(v*v+z*z+b*b),x?(x=1/x,v*=x,z*=x,b*=x):(v=0,z=0,b=0),t[0]=g,t[1]=v,t[2]=y,t[3]=0,t[4]=q,t[5]=z,t[6]=m,t[7]=0,t[8]=w,t[9]=b,t[10]=f,t[11]=0,t[12]=-(g*r+q*i+w*c),t[13]=-(v*r+z*i+b*c),t[14]=-(y*r+m*i+f*c),t[15]=1,t}static targetTo(t,s,e,n){const r=s[0],i=s[1],c=s[2],a=n[0],l=n[1],h=n[2];let o=r-e[0],d=i-e[1],M=c-e[2],y=o*o+d*d+M*M;y>0&&(y=1/Math.sqrt(y),o*=y,d*=y,M*=y);let m=l*M-h*d,f=h*o-a*M,x=a*d-l*o;return y=m*m+f*f+x*x,y>0&&(y=1/Math.sqrt(y),m*=y,f*=y,x*=y),t[0]=m,t[1]=f,t[2]=x,t[3]=0,t[4]=d*x-M*f,t[5]=M*m-o*x,t[6]=o*f-d*m,t[7]=0,t[8]=o,t[9]=d,t[10]=M,t[11]=0,t[12]=r,t[13]=i,t[14]=c,t[15]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8]+t[9]*t[9]+t[10]*t[10]+t[11]*t[11]+t[12]*t[12]+t[13]*t[13]+t[14]*t[14]+t[15]*t[15])}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t[3]=s[3]+e[3],t[4]=s[4]+e[4],t[5]=s[5]+e[5],t[6]=s[6]+e[6],t[7]=s[7]+e[7],t[8]=s[8]+e[8],t[9]=s[9]+e[9],t[10]=s[10]+e[10],t[11]=s[11]+e[11],t[12]=s[12]+e[12],t[13]=s[13]+e[13],t[14]=s[14]+e[14],t[15]=s[15]+e[15],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t[3]=s[3]-e[3],t[4]=s[4]-e[4],t[5]=s[5]-e[5],t[6]=s[6]-e[6],t[7]=s[7]-e[7],t[8]=s[8]-e[8],t[9]=s[9]-e[9],t[10]=s[10]-e[10],t[11]=s[11]-e[11],t[12]=s[12]-e[12],t[13]=s[13]-e[13],t[14]=s[14]-e[14],t[15]=s[15]-e[15],t}static sub(t,s,e){return t}static multiplyScalar(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t[4]=s[4]*e,t[5]=s[5]*e,t[6]=s[6]*e,t[7]=s[7]*e,t[8]=s[8]*e,t[9]=s[9]*e,t[10]=s[10]*e,t[11]=s[11]*e,t[12]=s[12]*e,t[13]=s[13]*e,t[14]=s[14]*e,t[15]=s[15]*e,t}static multiplyScalarAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t[3]=s[3]+e[3]*n,t[4]=s[4]+e[4]*n,t[5]=s[5]+e[5]*n,t[6]=s[6]+e[6]*n,t[7]=s[7]+e[7]*n,t[8]=s[8]+e[8]*n,t[9]=s[9]+e[9]*n,t[10]=s[10]+e[10]*n,t[11]=s[11]+e[11]*n,t[12]=s[12]+e[12]*n,t[13]=s[13]+e[13]*n,t[14]=s[14]+e[14]*n,t[15]=s[15]+e[15]*n,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]&&t[9]===s[9]&&t[10]===s[10]&&t[11]===s[11]&&t[12]===s[12]&&t[13]===s[13]&&t[14]===s[14]&&t[15]===s[15]}static equals(t,s){const e=t[0],n=t[1],r=t[2],i=t[3],c=t[4],a=t[5],l=t[6],h=t[7],o=t[8],d=t[9],M=t[10],y=t[11],m=t[12],f=t[13],x=t[14],g=t[15],q=s[0],w=s[1],v=s[2],z=s[3],b=s[4],S=s[5],D=s[6],C=s[7],E=s[8],V=s[9],L=s[10],F=s[11],A=s[12],k=s[13],Y=s[14],j=s[15];return Math.abs(e-q)<=I*Math.max(1,Math.abs(e),Math.abs(q))&&Math.abs(n-w)<=I*Math.max(1,Math.abs(n),Math.abs(w))&&Math.abs(r-v)<=I*Math.max(1,Math.abs(r),Math.abs(v))&&Math.abs(i-z)<=I*Math.max(1,Math.abs(i),Math.abs(z))&&Math.abs(c-b)<=I*Math.max(1,Math.abs(c),Math.abs(b))&&Math.abs(a-S)<=I*Math.max(1,Math.abs(a),Math.abs(S))&&Math.abs(l-D)<=I*Math.max(1,Math.abs(l),Math.abs(D))&&Math.abs(h-C)<=I*Math.max(1,Math.abs(h),Math.abs(C))&&Math.abs(o-E)<=I*Math.max(1,Math.abs(o),Math.abs(E))&&Math.abs(d-V)<=I*Math.max(1,Math.abs(d),Math.abs(V))&&Math.abs(M-L)<=I*Math.max(1,Math.abs(M),Math.abs(L))&&Math.abs(y-F)<=I*Math.max(1,Math.abs(y),Math.abs(F))&&Math.abs(m-A)<=I*Math.max(1,Math.abs(m),Math.abs(A))&&Math.abs(f-k)<=I*Math.max(1,Math.abs(f),Math.abs(k))&&Math.abs(x-Y)<=I*Math.max(1,Math.abs(x),Math.abs(Y))&&Math.abs(g-j)<=I*Math.max(1,Math.abs(g),Math.abs(j))}static str(t){return`Mat4(${t.join(", ")})`}};T(N,"BYTE_LENGTH",16*Float32Array.BYTES_PER_ELEMENT);let U=N;const R=new Float32Array(3);U.prototype.mul=U.prototype.multiply;U.sub=U.subtract;U.mul=U.multiply;U.frustum=U.frustumNO;U.perspective=U.perspectiveNO;U.ortho=U.orthoNO;const O=class O extends Float32Array{constructor(...t){switch(t.length){case 3:super(t);break;case 2:super(t[0],t[1],3);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s]):super(s,0,3);break}default:super(3);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get magnitude(){const t=this[0],s=this[1],e=this[2];return Math.sqrt(t*t+s*s+e*e)}get mag(){return this.magnitude}get squaredMagnitude(){const t=this[0],s=this[1],e=this[2];return t*t+s*s+e*e}get sqrMag(){return this.squaredMagnitude}get str(){return O.str(this)}copy(t){return this.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this[2]+=t[2]*s,this}distance(t){return O.distance(this,t)}dist(t){return 0}squaredDistance(t){return O.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this[2]=Math.abs(this[2]),this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]}normalize(){return O.normalize(this,this)}static create(){return new O}static clone(t){return new O(t)}static magnitude(t){let s=t[0],e=t[1],n=t[2];return Math.sqrt(s*s+e*e+n*n)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static fromValues(t,s,e){return new O(t,s,e)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t}static set(t,s,e,n){return t[0]=s,t[1]=e,t[2]=n,t}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t}static sub(t,s,e){return[0,0,0]}static multiply(t,s,e){return t[0]=s[0]*e[0],t[1]=s[1]*e[1],t[2]=s[2]*e[2],t}static mul(t,s,e){return[0,0,0]}static divide(t,s,e){return t[0]=s[0]/e[0],t[1]=s[1]/e[1],t[2]=s[2]/e[2],t}static div(t,s,e){return[0,0,0]}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t[2]=Math.ceil(s[2]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t[2]=Math.floor(s[2]),t}static min(t,s,e){return t[0]=Math.min(s[0],e[0]),t[1]=Math.min(s[1],e[1]),t[2]=Math.min(s[2],e[2]),t}static max(t,s,e){return t[0]=Math.max(s[0],e[0]),t[1]=Math.max(s[1],e[1]),t[2]=Math.max(s[2],e[2]),t}static scale(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t}static scaleAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t}static distance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2];return Math.sqrt(e*e+n*n+r*r)}static dist(t,s){return 0}static squaredDistance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2];return e*e+n*n+r*r}static sqrDist(t,s){return 0}static squaredLength(t){const s=t[0],e=t[1],n=t[2];return s*s+e*e+n*n}static sqrLen(t,s){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t[2]=1/s[2],t}static abs(t,s){return t[0]=Math.abs(s[0]),t[1]=Math.abs(s[1]),t[2]=Math.abs(s[2]),t}static normalize(t,s){const e=s[0],n=s[1],r=s[2];let i=e*e+n*n+r*r;return i>0&&(i=1/Math.sqrt(i)),t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]}static cross(t,s,e){const n=s[0],r=s[1],i=s[2],c=e[0],a=e[1],l=e[2];return t[0]=r*l-i*a,t[1]=i*c-n*l,t[2]=n*a-r*c,t}static lerp(t,s,e,n){const r=s[0],i=s[1],c=s[2];return t[0]=r+n*(e[0]-r),t[1]=i+n*(e[1]-i),t[2]=c+n*(e[2]-c),t}static slerp(t,s,e,n){const r=Math.acos(Math.min(Math.max(O.dot(s,e),-1),1)),i=Math.sin(r),c=Math.sin((1-n)*r)/i,a=Math.sin(n*r)/i;return t[0]=c*s[0]+a*e[0],t[1]=c*s[1]+a*e[1],t[2]=c*s[2]+a*e[2],t}static hermite(t,s,e,n,r,i){const c=i*i,a=c*(2*i-3)+1,l=c*(i-2)+i,h=c*(i-1),o=c*(3-2*i);return t[0]=s[0]*a+e[0]*l+n[0]*h+r[0]*o,t[1]=s[1]*a+e[1]*l+n[1]*h+r[1]*o,t[2]=s[2]*a+e[2]*l+n[2]*h+r[2]*o,t}static bezier(t,s,e,n,r,i){const c=1-i,a=c*c,l=i*i,h=a*c,o=3*i*a,d=3*l*c,M=l*i;return t[0]=s[0]*h+e[0]*o+n[0]*d+r[0]*M,t[1]=s[1]*h+e[1]*o+n[1]*d+r[1]*M,t[2]=s[2]*h+e[2]*o+n[2]*d+r[2]*M,t}static transformMat4(t,s,e){const n=s[0],r=s[1],i=s[2],c=e[3]*n+e[7]*r+e[11]*i+e[15]||1;return t[0]=(e[0]*n+e[4]*r+e[8]*i+e[12])/c,t[1]=(e[1]*n+e[5]*r+e[9]*i+e[13])/c,t[2]=(e[2]*n+e[6]*r+e[10]*i+e[14])/c,t}static transformMat3(t,s,e){let n=s[0],r=s[1],i=s[2];return t[0]=n*e[0]+r*e[3]+i*e[6],t[1]=n*e[1]+r*e[4]+i*e[7],t[2]=n*e[2]+r*e[5]+i*e[8],t}static transformQuat(t,s,e){const n=e[0],r=e[1],i=e[2],c=e[3]*2,a=s[0],l=s[1],h=s[2],o=r*h-i*l,d=i*a-n*h,M=n*l-r*a,y=(r*M-i*d)*2,m=(i*o-n*M)*2,f=(n*d-r*o)*2;return t[0]=a+o*c+y,t[1]=l+d*c+m,t[2]=h+M*c+f,t}static rotateX(t,s,e,n){const r=e[1],i=e[2],c=s[1]-r,a=s[2]-i;return t[0]=s[0],t[1]=c*Math.cos(n)-a*Math.sin(n)+r,t[2]=c*Math.sin(n)+a*Math.cos(n)+i,t}static rotateY(t,s,e,n){const r=e[0],i=e[2],c=s[0]-r,a=s[2]-i;return t[0]=a*Math.sin(n)+c*Math.cos(n)+r,t[1]=s[1],t[2]=a*Math.cos(n)-c*Math.sin(n)+i,t}static rotateZ(t,s,e,n){const r=e[0],i=e[1],c=s[0]-r,a=s[1]-i;return t[0]=c*Math.cos(n)-a*Math.sin(n)+r,t[1]=c*Math.sin(n)+a*Math.cos(n)+i,t[2]=e[2],t}static angle(t,s){const e=t[0],n=t[1],r=t[2],i=s[0],c=s[1],a=s[2],l=Math.sqrt((e*e+n*n+r*r)*(i*i+c*c+a*a)),h=l&&O.dot(t,s)/l;return Math.acos(Math.min(Math.max(h,-1),1))}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t}static str(t){return`Vec3(${t.join(", ")})`}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]}static equals(t,s){const e=t[0],n=t[1],r=t[2],i=s[0],c=s[1],a=s[2];return Math.abs(e-i)<=I*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(n-c)<=I*Math.max(1,Math.abs(n),Math.abs(c))&&Math.abs(r-a)<=I*Math.max(1,Math.abs(r),Math.abs(a))}};T(O,"BYTE_LENGTH",3*Float32Array.BYTES_PER_ELEMENT);let p=O;p.prototype.sub=p.prototype.subtract;p.prototype.mul=p.prototype.multiply;p.prototype.div=p.prototype.divide;p.prototype.dist=p.prototype.distance;p.prototype.sqrDist=p.prototype.squaredDistance;p.sub=p.subtract;p.mul=p.multiply;p.div=p.divide;p.dist=p.distance;p.sqrDist=p.squaredDistance;p.sqrLen=p.squaredLength;p.mag=p.magnitude;p.length=p.magnitude;p.len=p.magnitude;const G=class G extends Float32Array{constructor(...t){switch(t.length){case 2:{const s=t[0];typeof s=="number"?super([s,t[1]]):super(s,t[1],2);break}case 1:{const s=t[0];typeof s=="number"?super([s,s]):super(s,0,2);break}default:super(2);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get magnitude(){return Math.hypot(this[0],this[1])}get mag(){return this.magnitude}get squaredMagnitude(){const t=this[0],s=this[1];return t*t+s*s}get sqrMag(){return this.squaredMagnitude}get str(){return G.str(this)}copy(t){return this.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this}distance(t){return G.distance(this,t)}dist(t){return 0}squaredDistance(t){return G.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this}dot(t){return this[0]*t[0]+this[1]*t[1]}normalize(){return G.normalize(this,this)}static create(){return new G}static clone(t){return new G(t)}static fromValues(t,s){return new G(t,s)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t}static set(t,s,e){return t[0]=s,t[1]=e,t}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t}static sub(t,s,e){return[0,0]}static multiply(t,s,e){return t[0]=s[0]*e[0],t[1]=s[1]*e[1],t}static mul(t,s,e){return[0,0]}static divide(t,s,e){return t[0]=s[0]/e[0],t[1]=s[1]/e[1],t}static div(t,s,e){return[0,0]}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t}static min(t,s,e){return t[0]=Math.min(s[0],e[0]),t[1]=Math.min(s[1],e[1]),t}static max(t,s,e){return t[0]=Math.max(s[0],e[0]),t[1]=Math.max(s[1],e[1]),t}static round(t,s){return t[0]=Math.round(s[0]),t[1]=Math.round(s[1]),t}static scale(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t}static scaleAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t}static distance(t,s){return Math.hypot(s[0]-t[0],s[1]-t[1])}static dist(t,s){return 0}static squaredDistance(t,s){const e=s[0]-t[0],n=s[1]-t[1];return e*e+n*n}static sqrDist(t,s){return 0}static magnitude(t){let s=t[0],e=t[1];return Math.sqrt(s*s+e*e)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){const s=t[0],e=t[1];return s*s+e*e}static sqrLen(t,s){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t}static abs(t,s){return t[0]=Math.abs(s[0]),t[1]=Math.abs(s[1]),t}static normalize(t,s){const e=s[0],n=s[1];let r=e*e+n*n;return r>0&&(r=1/Math.sqrt(r)),t[0]=s[0]*r,t[1]=s[1]*r,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]}static cross(t,s,e){const n=s[0]*e[1]-s[1]*e[0];return t[0]=t[1]=0,t[2]=n,t}static lerp(t,s,e,n){const r=s[0],i=s[1];return t[0]=r+n*(e[0]-r),t[1]=i+n*(e[1]-i),t}static transformMat2(t,s,e){const n=s[0],r=s[1];return t[0]=e[0]*n+e[2]*r,t[1]=e[1]*n+e[3]*r,t}static transformMat2d(t,s,e){const n=s[0],r=s[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}static transformMat3(t,s,e){const n=s[0],r=s[1];return t[0]=e[0]*n+e[3]*r+e[6],t[1]=e[1]*n+e[4]*r+e[7],t}static transformMat4(t,s,e){const n=s[0],r=s[1];return t[0]=e[0]*n+e[4]*r+e[12],t[1]=e[1]*n+e[5]*r+e[13],t}static rotate(t,s,e,n){const r=s[0]-e[0],i=s[1]-e[1],c=Math.sin(n),a=Math.cos(n);return t[0]=r*a-i*c+e[0],t[1]=r*c+i*a+e[1],t}static angle(t,s){const e=t[0],n=t[1],r=s[0],i=s[1],c=Math.sqrt(e*e+n*n)*Math.sqrt(r*r+i*i),a=c&&(e*r+n*i)/c;return Math.acos(Math.min(Math.max(a,-1),1))}static zero(t){return t[0]=0,t[1]=0,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]}static equals(t,s){const e=t[0],n=t[1],r=s[0],i=s[1];return Math.abs(e-r)<=I*Math.max(1,Math.abs(e),Math.abs(r))&&Math.abs(n-i)<=I*Math.max(1,Math.abs(n),Math.abs(i))}static str(t){return`Vec2(${t.join(", ")})`}};T(G,"BYTE_LENGTH",2*Float32Array.BYTES_PER_ELEMENT);let B=G;B.prototype.sub=B.prototype.subtract;B.prototype.mul=B.prototype.multiply;B.prototype.div=B.prototype.divide;B.prototype.dist=B.prototype.distance;B.prototype.sqrDist=B.prototype.squaredDistance;B.sub=B.subtract;B.mul=B.multiply;B.div=B.divide;B.dist=B.distance;B.sqrDist=B.squaredDistance;B.sqrLen=B.squaredLength;B.mag=B.magnitude;B.length=B.magnitude;B.len=B.magnitude;const K=String.raw;class _{constructor(t,s,e,n){T(this,"p");T(this,"target");T(this,"up");T(this,"aspect");T(this,"fov");T(this,"near");T(this,"far");T(this,"spherical",new p);T(this,"canvas");T(this,"lastMouse");T(this,"clicked");this.p=p.fromValues(0,0,0),this.target=p.fromValues(0,0,0),this.up=p.fromValues(0,1,0),this.aspect=s,this.fov=Math.PI/4,this.near=.1,this.far=100,this.target=n?p.clone(n):p.fromValues(0,0,0),this.p=e?p.clone(e):p.fromValues(0,0,15),this.calculateSphericalCoordinates(),this.canvas=t,this.lastMouse={x:0,y:0},this.clicked=!1,this.setupEventListeners(),this.updatePosition()}calculateSphericalCoordinates(){const t=p.sub(p.create(),this.p,this.target),s=p.length(t),e=Math.atan2(t[2],t[0]),n=Math.acos(t[1]/s);this.spherical=p.fromValues(s,e,n)}setPosition(t,s){p.copy(this.p,t),s&&p.copy(this.target,s),this.calculateSphericalCoordinates(),this.updatePosition()}setupEventListeners(){window.addEventListener("keydown",({code:s})=>{switch(s){case"KeyA":case"ArrowLeft":this.p.x-=1,this.target.x-=1;break;case"KeyD":case"ArrowRight":this.p.x+=1,this.target.x+=1;break;case"KeyW":case"ArrowUp":this.p.z-=1,this.target.z-=1;break;case"KeyS":case"ArrowDown":this.p.z+=1,this.target.z+=1;break;case"KeyQ":this.p.y-=1,this.target.y-=1;break;case"KeyE":this.p.y+=1,this.target.y+=1;break}}),this.canvas.addEventListener("mousedown",s=>{this.clicked=!0,this.lastMouse.x=s.clientX,this.lastMouse.y=s.clientY}),window.addEventListener("mouseup",()=>{this.clicked=!1}),this.canvas.addEventListener("mousemove",s=>{if(this.clicked){const e=s.clientX-this.lastMouse.x,n=s.clientY-this.lastMouse.y;this.rotate(e,n),this.lastMouse.x=s.clientX,this.lastMouse.y=s.clientY}}),this.canvas.addEventListener("wheel",s=>{this.zoom(s.deltaY),s.preventDefault()})}rotate(t,s){this.spherical[1]-=t*.01,this.spherical[2]=Math.max(.1,Math.min(Math.PI-.1,this.spherical[2]+s*.01)),this.updatePosition()}zoom(t){this.spherical[0]=Math.max(1,this.spherical[0]+t*.005),this.updatePosition()}updatePosition(){const[t,s,e]=this.spherical;this.p=p.fromValues(t*Math.sin(e)*Math.cos(s),t*Math.cos(e),t*Math.sin(e)*Math.sin(s)),p.add(this.p,this.p,this.target)}pan(t,s){const n=p.cross(p.create(),p.subtract(p.create(),this.target,this.p),this.up);p.normalize(n,n);const r=p.scale(p.create(),n,-t*.005),i=p.scale(p.create(),this.up,-s*.005);p.add(this.p,this.p,r),p.add(this.p,this.p,i),p.add(this.target,this.target,r),p.add(this.target,this.target,i)}getViewProjectionMatrix(){const t=U.lookAt(U.create(),this.p,this.target,this.up),s=U.perspective(U.create(),this.fov,this.aspect,this.near,this.far);return U.multiply(U.create(),s,t)}}class u{constructor(){T(this,"p");T(this,"color");this.p=p.fromValues(100,100,100),this.color=p.fromValues(1,1,1)}}class tt{constructor(t){T(this,"canvas");T(this,"context");T(this,"adapter");T(this,"device");T(this,"textureFormat");T(this,"vertexBuffers",[]);T(this,"indexBuffers",[]);T(this,"indexCounts",[]);T(this,"camera");T(this,"light");T(this,"resize",()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight;const t=window.devicePixelRatio||1;if(this.canvas.width=window.innerWidth*t,this.canvas.height=window.innerHeight*t,this.canvas.style.width=window.innerWidth+"px",this.canvas.style.height=window.innerHeight+"px",this.device&&this.textureFormat){const s={device:this.device,format:this.textureFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"opaque"};this.context.configure(s)}this.camera.aspect=this.canvas.width/this.canvas.height});T(this,"render",(t,s)=>{const n=this.device.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=new Float32Array(96/4);r.set(this.camera.getViewProjectionMatrix(),0),r.set(this.camera.p,16),r.set(this.light.p,20),this.device.queue.writeBuffer(n,0,r);const i=new Float32Array(s.objects.length*3);s.objects.forEach((x,g)=>{i.set([x.p.x,x.p.y,x.p.z],g*3)}),s.objects.forEach((x,g)=>{if(!x.data)return;const{vertexData:q,indexData:w}=x.data,v=this.device.createBuffer({label:`vertex buffer ${g}`,size:q.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(v,0,q),this.vertexBuffers[g]=v;const z=this.device.createBuffer({label:`index buffer ${g}`,size:w.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(z,0,w),this.indexBuffers[g]=z,this.indexCounts[g]=w.length});const c=this.device.createBuffer({label:"instance buffer",size:i.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(c,0,i);const a=this.device.createShaderModule({label:"main module",code:K`
        @binding(0) @group(0) var<uniform> uniforms : Uniforms;
        struct Uniforms {
          viewProjectionMatrix: mat4x4<f32>,
          cameraP: vec3<f32>,
          lightP: vec3<f32>,
        };

        struct VertexInput {
          @builtin(vertex_index) vI: u32,
          @location(0) p: vec3f,
          @location(1) normal: vec3f,
          @location(2) color: vec3f,
          @location(3) instanceP: vec3f,
        };

        struct VertexOutput {
          @builtin(position) p: vec4f,
          @location(0) worldP: vec3f,
          @location(1) normal: vec3f,
          @location(2) @interpolate(flat) color: vec3f
        };

        @vertex fn vs(input: VertexInput) -> VertexOutput {
          var output: VertexOutput;
          var worldP = input.p + input.instanceP;  
          // stop clipping when folded over in Y
          worldP.y = worldP.y - f32(input.vI) * 0.000001;
          output.p = uniforms.viewProjectionMatrix * vec4f(worldP, 1.0);
          output.worldP = worldP;
          output.normal = input.normal;
          output.color = input.color;
          return output;
        }

        @fragment fn fs(input: VertexOutput) -> @location(0) vec4f {
          let lightColor = vec3f(1.0, 1.0, 1.0);
          let objectColor = input.color;  
          let ambientStrength = 0.3;
          let specularStrength = 1.5;
          let shininess = 1.0;
          // Ambient
          let ambient = ambientStrength * lightColor;
          // Diffuse
          let normalizedNormal = normalize(input.normal);
          let lightDir = normalize(uniforms.lightP - input.worldP);
          let diff = max(dot(normalizedNormal, lightDir), 0.0);
          let diffuse = diff * lightColor;
          // Specular
          let viewDir = normalize(uniforms.cameraP - input.worldP);
          let reflectDir = reflect(-lightDir, normalizedNormal);
          let spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
          let specular = specularStrength * spec * lightColor;
          let result = (ambient + diffuse + specular) * objectColor;
          return vec4f(result, 1.0);
        }


`}),l=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),h=this.device.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:n}}]}),o=this.device.createRenderPipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[l]}),vertex:{module:a,buffers:[{arrayStride:9*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*4,format:"float32x3"},{shaderLocation:2,offset:6*4,format:"float32x3"}],stepMode:"vertex"},{arrayStride:3*4,attributes:[{shaderLocation:3,offset:0,format:"float32x3"}],stepMode:"instance"}]},fragment:{module:a,entryPoint:"fs",targets:[{format:this.textureFormat}]},primitive:{topology:"triangle-list",cullMode:"none",frontFace:"ccw"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),d=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),M={colorAttachments:[]};M.colorAttachments=[{view:this.context.getCurrentTexture().createView(),clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}],M.depthStencilAttachment={view:d.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"};const y=this.device.createCommandEncoder(),m=y.beginRenderPass(M);m.setPipeline(o),m.setBindGroup(0,h),s.objects.forEach((x,g)=>{m.setVertexBuffer(0,this.vertexBuffers[g]),m.setVertexBuffer(1,c),m.setIndexBuffer(this.indexBuffers[g],"uint32"),m.drawIndexed(this.indexCounts[g],1,0,0,g)}),m.end();const f=y.finish();this.device.queue.submit([f])});this.canvas=t,this.context=(s=>{if(s===null)throw new Error("Failed to get canvas context");return s})(this.canvas.getContext("webgpu")),this.camera=new _(this.canvas,this.canvas.width/this.canvas.height,new p(0,9,9)),this.light=new u}async init(){const t=navigator.gpu;if(!t)throw new Error("Failed to connect to GPU, your device or browser might not support webGPU yet.");this.adapter=(s=>{if(s===null)throw new Error("Failed to get adapter");return s})(await t.requestAdapter()),this.device=(s=>{if(s===null)throw new Error;return s})(await this.adapter.requestDevice()),this.device.lost.then(s=>{console.error(`WebGPU device was lost: ${s.message}`)}),this.textureFormat=navigator.gpu.getPreferredCanvasFormat(),this.resize(),window.addEventListener("resize",this.resize)}}class st{constructor(){T(this,"g",new p(0,-9.8,0));T(this,"step",async(t,s,e,n)=>{const r=new B(s.width,s.length).divide(s.divisions),i=10,c=t/i;for(let a=0;a<i;a++)this.updatePositions(s,c),this.solveConstraints(s,r),this.handleCollisions(s,e,n);this.updateVertexBuffer(s),this.updateNormals(s)})}updatePositions(t,s){for(const e of t.vertices){const n=p.clone(e.p);let r=p.clone(e.p);r.scale(2),r.sub(e.lastP);let i=p.scale(new p,this.g,s*s);r.add(i),e.p=r,e.lastP=n}}solveConstraints(t,s){const e=t.divisions.x+1,n=t.divisions.y+1;for(let r=0;r<t.vertices.length;r++){const i=r%e,c=Math.floor(r/e),a=t.vertices[r];[c>0?t.vertices[(c-1)*e+i]:null,i<e-1?t.vertices[c*e+i+1]:null,c<n-1?t.vertices[(c+1)*e+i]:null,i>0?t.vertices[c*e+i-1]:null,i<e-2?t.vertices[c*e+i+2]:null,c<n-2?t.vertices[(c+2)*e+i]:null,c>0&&i>0?t.vertices[(c-1)*e+i-1]:null,c>0&&i<e-1?t.vertices[(c-1)*e+i+1]:null,c<n-1&&i>0?t.vertices[(c+1)*e+i-1]:null,c<n-1&&i<e-1?t.vertices[(c+1)*e+i+1]:null].forEach((h,o)=>{if(h){let d,M;o<4?(d=o%2===0?s.x:s.y,M=.2):o<6?(d=o%2===0?s.x*2:s.y*2,M=.2):(d=Math.sqrt(s.x*s.x+s.y*s.y),M=.1);const y=p.subtract(new p,h.p,a.p),m=y.magnitude,f=y.scale((m-d)/m*M);a.p.add(f),h.p.subtract(f)}})}}handleCollisions(t,s,e){for(const i of t.vertices){const c=p.add(new p,t.p,i.p),a=p.distance(c,s.p)-s.radius;if(a<=.1){const h=p.subtract(new p,c,s.p).normalize(),o=s.radius+.1-a,d=h.scale(o*.004);i.p.add(d),i.lastP.add(d.scale(.5))}const l=c.y;if(l<=.1&&c.x<e.width/2&&c.x>-e.width/2&&c.z<e.length/2&&c.z>-e.length/2){const h=.1-l,o=new p(0,1,0).scale(h);i.p.add(o);const d=p.subtract(new p,i.p,i.lastP);d.x*=1-.01,d.z*=1-.01,d.y*=-.2,i.lastP=p.subtract(new p,i.p,d)}}}updateVertexBuffer(t){const s=t.data.vertexData;for(let e=0;e<t.vertices.length;e++){const n=e*9;s[n]=t.vertices[e].p[0],s[n+1]=t.vertices[e].p[1],s[n+2]=t.vertices[e].p[2]}}updateNormals(t){const s=t.vertices.map(()=>new p(0,0,0)),e=(r,i,c)=>{const a=p.subtract(p.create(),i,r),l=p.subtract(p.create(),c,r),h=p.cross(p.create(),a,l);return p.normalize(h,h),h};for(let r=0;r<t.data.indexData.length;r+=3){const i=t.data.indexData[r],c=t.data.indexData[r+1],a=t.data.indexData[r+2],l=t.vertices[i].p,h=t.vertices[c].p,o=t.vertices[a].p,d=e(l,h,o);p.add(s[i],s[i],d),p.add(s[c],s[c],d),p.add(s[a],s[a],d)}s.forEach(r=>p.normalize(r,r));const n=t.data.vertexData;for(let r=0;r<t.vertices.length;r++){const i=r*9;n[i+3]=s[r].x,n[i+4]=s[r].y,n[i+5]=s[r].z}}}var X=(P=>(P[P.Box=0]="Box",P[P.Sphere=1]="Sphere",P[P.Model=2]="Model",P[P.Cloth=3]="Cloth",P))(X||{});class et{constructor(t){T(this,"objects",[]);T(this,"getVertices",async()=>{for(const t of this.objects)switch(t.kind){case 0:rt(t);break;case 1:it(t);break;case 2:let s=await fetch("teapot.obj").then(e=>e.text());ct(t,s);break;case 3:at(t);break}});this.objects=t}}const nt=(P,t,s,e,n,r,i)=>{const[c,a,l]=[P.length/2,P.width/2,P.height/2],h=[],o=[];for(let d=0;d<=n;d++)for(let M=0;M<=r;M++){const y=d/n*2-1,m=M/r*2-1,f=[0,0,0,0,0,0,...P.color];if(f[t]=y*(t===0?c:t===1?l:a),f[s]=m*(s===0?c:s===1?l:a),f[e]=i*(e===0?c:e===1?l:a),f[3+e]=i,h.push(...f),d<n&&M<r){const x=d*(r+1)+M;i===1?o.push(x,x+1,x+r+2,x,x+r+2,x+r+1):o.push(x+r+1,x+1,x,x+r+1,x+r+2,x+1)}}return{vertices:h,indices:o}},rt=P=>{const t=P.divisions??new p(1,1,1),s=[{uAxis:0,vAxis:1,fixedAxis:2,uDiv:t.x,vDiv:t.y,sign:-1},{uAxis:0,vAxis:1,fixedAxis:2,uDiv:t.x,vDiv:t.y,sign:1},{uAxis:0,vAxis:2,fixedAxis:1,uDiv:t.x,vDiv:t.z,sign:-1},{uAxis:0,vAxis:2,fixedAxis:1,uDiv:t.x,vDiv:t.z,sign:1},{uAxis:2,vAxis:1,fixedAxis:0,uDiv:t.z,vDiv:t.y,sign:1},{uAxis:2,vAxis:1,fixedAxis:0,uDiv:t.z,vDiv:t.y,sign:-1}];let e=[],n=[],r=0;s.forEach(i=>{const{vertices:c,indices:a}=nt(P,i.uAxis,i.vAxis,i.fixedAxis,i.uDiv,i.vDiv,i.sign);e.push(...c),n.push(...a.map(l=>l+r)),r+=c.length/9}),P.data={vertexData:new Float32Array(e),indexData:new Uint32Array(n)}},it=P=>{const t=P.radius,s=P.hPrec,e=P.vPrec,n=2+s*e,r=new Float32Array(n*9);let i=0;r.set([0,t,0,0,1,0,...P.color],i),i+=9;for(let o=0;o<e;o++){const d=(o+1)/(e+1)*Math.PI,M=t*Math.cos(d),y=t*Math.sin(d);for(let m=0;m<s;m++){const f=m/s*2*Math.PI,x=Math.cos(f)*y,g=Math.sin(f)*y,q=[x,M,g],w=new p(x,M,g).normalize(),v=P.color;r.set([...q,...w,...v],i),i+=9}}r.set([0,-t,0,0,-1,0,...P.color],i);const c=e*s*6,a=new Uint32Array(c);let l=0;for(let o=0;o<s;o++)a.set([(o+1)%s+1,o+1,0],l),l+=3;for(let o=0;o<e-1;o++)for(let d=0;d<s;d++){const M=o*s+d+1,y=o*s+(d+1)%s+1,m=(o+1)*s+d+1,f=(o+1)*s+(d+1)%s+1;a.set([y,m,M],l),l+=3,a.set([f,m,y],l),l+=3}const h=n-1;for(let o=0;o<s;o++)a.set([h,h-s+o,h-s+(o+1)%s],l),l+=3;P.data={vertexData:r,indexData:a}},ct=(P,t)=>{const s=t.split(`
`);let e=[],n=[];for(const c of s){let[a,...l]=c.split(" ");if(a=="v"){let h=[...l.map(o=>Number(o))];e.push(...h,...new p(...h).normalize(),...P.color)}else if(a=="f"){let h=[...l.map(o=>Number(o)-1)];n.push(...h)}}const r=new Float32Array(e),i=new Uint32Array(n);P.data={vertexData:r,indexData:i}},at=P=>{const t=P.divisions??new B(1,1),s=[],e=[];for(let i=0;i<=t.y;i++){let c=i/t.y*P.length-P.length/2;for(let a=0;a<=t.x;a++){let l=a/t.x*P.width-P.width/2,h=(a/t.x+i/t.y)/2;if(s.push(l,0,c,0,1,0,Math.sin(2*Math.PI*h)*.5+.5,Math.sin(2*Math.PI*h+2*Math.PI/3)*.5+.5,Math.sin(2*Math.PI*h+4*Math.PI/3)*.5+.5),i!=t.y&&a!=t.x){let o=i*(t.x+1);e.push(o+a+1,o+a,(i+1)*(t.x+1)+a,o+a+1,(i+1)*(t.x+1)+a,(i+1)*(t.x+1)+a+1)}}}const n=new Float32Array(s),r=new Uint32Array(e);P.vertices=[];for(let i=0;i<s.length;i+=9)P.vertices.push({p:new p(s[i],s[i+1],s[i+2]),lastP:new p(s[i],s[i+1],s[i+2]),a:new p(0,0,0)});P.data={vertexData:n,indexData:r}},W=document.createElement("canvas");document.querySelector("#app").appendChild(W);const ht=async()=>{console.log("Start!");const P=new et([{kind:X.Box,length:15,width:15,height:.25,color:new p(30).scale(1/255),p:new p(0,-.125,0),v:new p(0,0,0),a:new p(0,0,0)},{kind:X.Sphere,radius:1,hPrec:50,vPrec:50,color:new p(30,50,250).scale(1/255),p:new p(0,1,0),v:new p(0,0,0),a:new p(0,0,0)},{kind:X.Cloth,length:3,width:3,divisions:new B(30),color:new p(220,220,220).scale(1/255),p:new p(0,5,0),v:new p(0,0,0),a:new p(0,0,0)},{kind:X.Model,filepath:"teapot.obj",color:new p(40).scale(1/255),p:new p(-5,0,-5),v:new p(0,0,0),a:new p(0,0,0)}]);try{const t=new st,s=new tt(W);await s.init(),await P.getVertices();const e=document.createElement("p");let n=0;e.style.margin="0",document.querySelector("#app").appendChild(e);const r=document.createElement("p");r.style.margin="0",document.querySelector("#app").appendChild(r);const i=performance.now();let c=i;const a=l=>{const h=(l-c)/1e3;t.step(h,P.objects[2],P.objects[1],P.objects[0]),s.render(l-i,P);let o=s.indexBuffers.reduce((d,M)=>d+M.size,0)/(3*4);n!=o&&(n=o,e.innerText=`${o} triangles`),r.innerText=`${Math.round(1/h)}fps`,c=l,requestAnimationFrame(d=>a(d))};requestAnimationFrame(a)}catch(t){console.error(t)}};ht();
